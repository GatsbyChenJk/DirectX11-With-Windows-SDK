## 一.chatGPT提供的思路

在DirectX 11中，纹理采样可以通过以下步骤来实现：

1. 创建一个纹理对象：使用D3D11_TEXTURE2D_DESC结构体描述纹理的属性，包括宽度、高度、格式、MIP级别等。
2. 创建一个纹理采样器对象：使用D3D11_SAMPLER_DESC结构体描述采样器的属性，包括过滤模式、边界模式、MIP级别等。
3. 将纹理对象和纹理采样器对象绑定到渲染管线的像素着色器阶段：使用ID3D11DeviceContext::PSSetShaderResources和ID3D11DeviceContext::PSSetSamplers函数将纹理和采样器对象绑定到像素着色器阶段的着色器资源和采样器寄存器上。
4. 在像素着色器中使用采样器对象对纹理进行采样：使用tex2D或tex2Dlod等纹理采样函数对纹理进行采样，并将采样结果作为像素颜色输出。

下面是一个简单的纹理采样的代码示例：

```hlsl
Texture2D tex;
SamplerState samp;

float4 PSMain(float4 pos : SV_POSITION, float2 texcoord : TEXCOORD) : SV_TARGET
{
    return tex.Sample(samp, texcoord);
}
```

在这个像素着色器中，使用了tex.Sample函数对纹理进行采样，并将采样结果作为像素颜色输出。samp是一个采样器对象，tex是一个纹理对象。

## 二.教程项目09中的做法
这里以设置木箱纹理为例进行说明
#### 1.用CreateDDsTextureFromFile函数从文件读取DDS纹理
函数参数如下所示：
```cpp
HRESULT CreateDDSTextureFromFile(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    const wchar_t* szFileName,              // [In]dds图片文件名
    ID3D11Resource** texture,               // [Out]输出一个指向资源接口类的指针，也可以填nullptr
    ID3D11ShaderResourceView** textureView, // [Out]输出一个指向着色器资源视图的指针，也可以填nullptr
    size_t maxsize = 0,                     // [In]忽略
    DDS_ALPHA_MODE* alphaMode = nullptr);  // [In]忽略
```
比如初始化木箱纹理可以这样做：

```cpp
// 初始化木箱纹理
HR(CreateDDSTextureFromFile(m_pd3dDevice.Get(), L"Texture\\WoodCrate.dds", nullptr, m_pWoodCrate.GetAddressOf()));
```
#### 2.修改HLSL代码，新建像素着色器
首先修改Basic.hlsli的代码
```cpp
#include "LightHelper.hlsli"

//新建的Texture2D变量和SamplerState变量
Texture2D gTex : register(t0);
SamplerState gSamLinear : register(s0);


cbuffer VSConstantBuffer : register(b0)
{
    matrix g_World; 
    matrix g_View;  
    matrix g_Proj;  
    matrix g_WorldInvTranspose;
}

cbuffer PSConstantBuffer : register(b1)
{
    DirectionalLight g_DirLight[10];
    PointLight g_PointLight[10];
    SpotLight g_SpotLight[10];
    Material g_Material;
    int g_NumDirLight;
    int g_NumPointLight;
    int g_NumSpotLight;
    float g_Pad1;

    float3 g_EyePosW;
    float g_Pad2;
}


struct VertexPosNormalTex
{
    float3 PosL : POSITION;
    float3 NormalL : NORMAL;
    float2 Tex : TEXCOORD;
};

struct VertexPosTex
{
    float3 PosL : POSITION;
    float2 Tex : TEXCOORD;
};

struct VertexPosHWNormalTex
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION;     // 在世界中的位置
    float3 NormalW : NORMAL;    // 法向量在世界中的方向
    float2 Tex : TEXCOORD;
};

struct VertexPosHTex
{
    float4 PosH : SV_POSITION;
    float2 Tex : TEXCOORD;
};
```
其中Texture2D类型用于保存2D纹理的信息，这里通过register绑定到寄存器t索引0位置
SamplerState类型用于确定采样器应如何进行采样，这里通过register绑定到寄存器s索引0位置

新建的2d像素着色器如下：

```cpp
// Basic_PS_2D.hlsl
#include "Basic.hlsli"

// 像素着色器(2D)
float4 PS_2D(VertexPosHTex pIn) : SV_Target
{
    return g_Tex.Sample(g_SamLinear, pIn.Tex);
}
```
其中返回值 g_Tex.Sample(g_SamLinear, pIn.Tex)是根据纹理坐标取出纹理对应位置最为接近的像素

3d像素着色器如下：

```cpp
// Basic_PS_3D.hlsl
#include "Basic.hlsli"

// 像素着色器(3D)
float4 PS_3D(VertexPosHWNormalTex pIn) : SV_Target
{
    // 标准化法向量
    pIn.NormalW = normalize(pIn.NormalW);

    // 顶点指向眼睛的向量
    float3 toEyeW = normalize(g_EyePosW - pIn.PosW);

    // 初始化为0 
    float4 ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 A = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 D = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 S = float4(0.0f, 0.0f, 0.0f, 0.0f);
    int i;

    for (i = 0; i < g_NumDirLight; ++i)
    {
        ComputeDirectionalLight(g_Material, g_DirLight[i], pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }
    
    for (i = 0; i < g_NumPointLight; ++i)
    {
        ComputePointLight(g_Material, g_PointLight[i], pIn.PosW, pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }
    
    for (i = 0; i < g_NumSpotLight; ++i)
    {
        ComputeSpotLight(g_Material, g_SpotLight[i], pIn.PosW, pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }
    

    float4 texColor = g_Tex.Sample(g_SamLinear, pIn.Tex);//纹理采样
    float4 litColor = texColor * (ambient + diffuse) + spec;
    litColor.a = texColor.a * g_Material.Diffuse.a;
    
    return litColor;
}
```
#### 3.在GameApp::InitEffect函数中创建顶点着色器和像素着色器，设置顶点布局

```cpp
bool GameApp::InitEffect()
{
    ComPtr<ID3DBlob> blob;

    // 创建顶点着色器(2D)
    HR(CreateShaderFromFile(L"HLSL\\Basic_VS_2D.cso", L"HLSL\\Basic_VS_2D.hlsl", "VS_2D", "vs_5_0", blob.ReleaseAndGetAddressOf()));
    HR(m_pd3dDevice->CreateVertexShader(blob->GetBufferPointer(), blob->GetBufferSize(), nullptr, m_pVertexShader2D.GetAddressOf()));
    // 创建顶点布局(2D)
    HR(m_pd3dDevice->CreateInputLayout(VertexPosTex::inputLayout, ARRAYSIZE(VertexPosTex::inputLayout),
        blob->GetBufferPointer(), blob->GetBufferSize(), m_pVertexLayout2D.GetAddressOf()));

    // 创建像素着色器(2D)
    HR(CreateShaderFromFile(L"HLSL\\Basic_PS_2D.cso", L"HLSL\\Basic_PS_2D.hlsl", "PS_2D", "ps_5_0", blob.ReleaseAndGetAddressOf()));
    HR(m_pd3dDevice->CreatePixelShader(blob->GetBufferPointer(), blob->GetBufferSize(), nullptr, m_pPixelShader2D.GetAddressOf()));

    // 创建顶点着色器(3D)
    HR(CreateShaderFromFile(L"HLSL\\Basic_VS_3D.cso", L"HLSL\\Basic_VS_3D.hlsl", "VS_3D", "vs_5_0", blob.ReleaseAndGetAddressOf()));
    HR(m_pd3dDevice->CreateVertexShader(blob->GetBufferPointer(), blob->GetBufferSize(), nullptr, m_pVertexShader3D.GetAddressOf()));
    // 创建顶点布局(3D)
    HR(m_pd3dDevice->CreateInputLayout(VertexPosNormalTex::inputLayout, ARRAYSIZE(VertexPosNormalTex::inputLayout),
        blob->GetBufferPointer(), blob->GetBufferSize(), m_pVertexLayout3D.GetAddressOf()));

    // 创建像素着色器(3D)
    HR(CreateShaderFromFile(L"HLSL\\Basic_PS_3D.cso", L"HLSL\\Basic_PS_3D.hlsl", "PS_3D", "ps_5_0", blob.ReleaseAndGetAddressOf()));
    HR(m_pd3dDevice->CreatePixelShader(blob->GetBufferPointer(), blob->GetBufferSize(), nullptr, m_pPixelShader3D.GetAddressOf()));

    return true;
}
```

#### 4.在GameApp::InitResourse函数中初始化纹理，新建采样器状态并设置采样器状态

```cpp
 // 初始化木箱纹理
    HR(CreateDDSTextureFromFile(m_pd3dDevice.Get(), L"Texture\\WoodCrate.dds", nullptr, m_pWoodCrate.GetAddressOf()));
 // 初始化采样器状态
    D3D11_SAMPLER_DESC sampDesc;
    ZeroMemory(&sampDesc, sizeof(sampDesc));
    sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
    sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
    sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
    sampDesc.MinLOD = 0;
    sampDesc.MaxLOD = D3D11_FLOAT32_MAX;
    HR(m_pd3dDevice->CreateSamplerState(&sampDesc, m_pSamplerState.GetAddressOf()));

```
#### 5.在GameApp::UpdateScene函数中更新画面

```cpp
void GameApp::UpdateScene(float dt)
{

    Keyboard::State state = m_pKeyboard->GetState();
    m_KeyboardTracker.Update(state);    

    // 键盘切换模式
    if (m_KeyboardTracker.IsKeyPressed(Keyboard::D1))
    {
        // 播放木箱动画
        m_CurrMode = ShowMode::WoodCrate;
        m_pd3dImmediateContext->IASetInputLayout(m_pVertexLayout3D.Get());
        auto meshData = Geometry::CreateBox();
        ResetMesh(meshData);
        m_pd3dImmediateContext->VSSetShader(m_pVertexShader3D.Get(), nullptr, 0);
        m_pd3dImmediateContext->PSSetShader(m_pPixelShader3D.Get(), nullptr, 0);
        m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pWoodCrate.GetAddressOf());
    }
   //其余部分...

    if (m_CurrMode == ShowMode::WoodCrate)
    {
        static float phi = 0.0f, theta = 0.0f;
        phi += 0.00003f, theta += 0.00005f;
        XMMATRIX W = XMMatrixRotationX(phi) * XMMatrixRotationY(theta);
        m_VSConstantBuffer.world = XMMatrixTranspose(W);
        m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(InverseTranspose(W));

        // 更新常量缓冲区，让立方体转起来
        D3D11_MAPPED_SUBRESOURCE mappedData;
        HR(m_pd3dImmediateContext->Map(m_pConstantBuffers[0].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedData));
        memcpy_s(mappedData.pData, sizeof(VSConstantBuffer), &m_VSConstantBuffer, sizeof(VSConstantBuffer));
        m_pd3dImmediateContext->Unmap(m_pConstantBuffers[0].Get(), 0);
    }
   //其余部分...
    }
}
```
# 三.基于项目09加入新的纹理并实现纹理采样的过程
#### 1.准备纹理
首先我在Quixel Bridge上下载了一个纹理，在文件夹中找到其纹理的jpg文件
![在这里插入图片描述](https://img-blog.csdnimg.cn/c48c657cd5e044b59eddb11d67bab9dd.png)
接着打开英伟达官方提供的软件NVIDIA Texture Tools Exporter将图片格式转换为dds格式的文件，直接将选中的图片拖到右边后就会变成下面的界面：
![在这里插入图片描述](https://img-blog.csdnimg.cn/5ca3f33cca7e4375a279ece5501b0dac.png)
需要检查左上角两项参数的设置，Format和Image type，要设置成图中的格式，接着点右下角的Save As...设置保存的格式和路径，如下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/6f0e0363c6f947cb913fb88149499cf4.png)
保存类型选择DDS，这里我将纹理文件命名为wall，这样纹理就准备好了。
#### 2.在GameApp.h中新定义用于调用wall纹理的变量和枚举值
wall的指针声明如下：

```cpp
ComPtr<ID3D11ShaderResourceView> m_pTestCrate;              //纹理采样测试用纹理
```

枚举设置如下：
```cpp
enum class ShowMode { WoodCrate, FireAnim,TestCrate };//TestCrate用于wall纹理
```
#### 3.在GameApp::InitResource中用CreateDDSTextureFromFile函数初始化wall纹理

```cpp
HR(CreateDDSTextureFromFile(m_pd3dDevice.Get(), L"..\\Texture\\wall.dds", nullptr, m_pTestCrate.GetAddressOf()));
```
#### 4.在GameApp::UpdateScene中增加wall纹理的更新画面
由于最新版的教程项目09将按键操作改成用imgui操作，所以基于imgui作修改
```cpp
void GameApp::UpdateScene(float dt)
{
    if (ImGui::Begin("Texture Mapping"))
    {
        static int curr_mode_item = static_cast<int>(m_CurrMode);
        const char* mode_strs[] = {
            "Box",
            "Fire Anim",
            "Test"//转换为wall纹理
        };
        if (ImGui::Combo("Mode", &curr_mode_item, mode_strs, ARRAYSIZE(mode_strs)))
        {
            if (curr_mode_item == 0)
            {
                // 播放木箱动画
                m_CurrMode = ShowMode::WoodCrate;
                m_pd3dImmediateContext->IASetInputLayout(m_pVertexLayout3D.Get());
                auto meshData = Geometry::CreateBox();
                ResetMesh(meshData);
                m_pd3dImmediateContext->VSSetShader(m_pVertexShader3D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShader(m_pPixelShader3D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pWoodCrate.GetAddressOf());
            }
            else if(curr_mode_item == 1)
            {
                m_CurrMode = ShowMode::FireAnim;
                m_CurrFrame = 0;
                m_pd3dImmediateContext->IASetInputLayout(m_pVertexLayout2D.Get());
                auto meshData = Geometry::Create2DShow();
                ResetMesh(meshData);
                m_pd3dImmediateContext->VSSetShader(m_pVertexShader2D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShader(m_pPixelShader2D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pFireAnims[0].GetAddressOf());
            }
            else//将状态改为显示wall纹理
            {
                m_CurrMode = ShowMode::TestCrate;
                m_pd3dImmediateContext->IASetInputLayout(m_pVertexLayout3D.Get());
                auto meshData = Geometry::CreateCone();//创建圆锥体
                ResetMesh(meshData);
                m_pd3dImmediateContext->VSSetShader(m_pVertexShader3D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShader(m_pPixelShader3D.Get(), nullptr, 0);
                m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pTestCrate.GetAddressOf());
            }

        }
    }
    ImGui::End();
    ImGui::Render();

    if (m_CurrMode == ShowMode::WoodCrate)
    {
        static float phi = 0.0f, theta = 0.0f;
        phi += 0.0001f, theta += 0.00015f;
        XMMATRIX W = XMMatrixRotationX(phi) * XMMatrixRotationY(theta);
        m_VSConstantBuffer.world = XMMatrixTranspose(W);
        //m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(InverseTranspose(W));
        static float alpha = 0.0f;
        alpha += 0.001f;//使纹理逆时针旋转
        XMMATRIX RotateMatrix = XMMatrixTranslation(-0.5f, -0.5f, 0.0f) * XMMatrixRotationZ(alpha) * XMMatrixTranslation(0.5f, 0.5f, 0.0f);
        m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(RotateMatrix);

        // 更新常量缓冲区，让立方体转起来
        D3D11_MAPPED_SUBRESOURCE mappedData;
        HR(m_pd3dImmediateContext->Map(m_pConstantBuffers[0].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedData));
        memcpy_s(mappedData.pData, sizeof(VSConstantBuffer), &m_VSConstantBuffer, sizeof(VSConstantBuffer));
        m_pd3dImmediateContext->Unmap(m_pConstantBuffers[0].Get(), 0);
    }
    else if (m_CurrMode == ShowMode::FireAnim)
    {
        // 用于限制在1秒60帧
        static float totDeltaTime = 0;

        totDeltaTime += dt;
        if (totDeltaTime > 1.0f / 60)
        {
            totDeltaTime -= 1.0f / 60;
            m_CurrFrame = (m_CurrFrame + 1) % 120;
            m_pd3dImmediateContext->PSSetShaderResources(0, 1, m_pFireAnims[m_CurrFrame].GetAddressOf());
        }		
    }
    else
    {     //显示wall纹理
            static float phiT = 0.0f, thetaT = 0.0f;
            phiT += 0.0001f, thetaT += 0.0001f;
            XMMATRIX W = XMMatrixRotationX(phiT) * XMMatrixRotationY(thetaT);
            m_VSConstantBuffer.world = XMMatrixTranspose(W);
            //m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(InverseTranspose(W));
            static float alphaT = 0.0f;
            alphaT -= 0.001f;//想使纹理逆时针旋转，但好像没转起来
            XMMATRIX RotateMatrix = XMMatrixTranslation(-0.5f, -0.5f, 0.0f) * XMMatrixRotationZ(alphaT) * XMMatrixTranslation(0.5f, 0.5f, 0.0f);
            m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(RotateMatrix);

            // 更新常量缓冲区，让圆锥体转起来
            D3D11_MAPPED_SUBRESOURCE mappedData;
            HR(m_pd3dImmediateContext->Map(m_pConstantBuffers[0].Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedData));
            memcpy_s(mappedData.pData, sizeof(VSConstantBuffer), &m_VSConstantBuffer, sizeof(VSConstantBuffer));
            m_pd3dImmediateContext->Unmap(m_pConstantBuffers[0].Get(), 0);
        
    }
}
```
#### 5.效果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/c75042c2cb7f44f9a825116861d834aa.gif#pic_center)

