# 线框模式的设置

## 1.准备工作

先在GameApp.h中新声明用于切换线框模式的变量

```cpp
ComPtr<ID3D11RasterizerState> m_pWireMode;      //光栅化模式:线框模式
    bool m_IsWireframeMode;							// 当前是否为线框模式
```

## 2.创建并初始化光栅化状态

准备工作完成后，在GameApp::InitResource函数中初始化光栅化状态，这里设置的填充方式是线框模式

```cpp
//初始化光栅化模式
    D3D11_RASTERIZER_DESC rasterizerDesc;
    ZeroMemory(&rasterizerDesc, sizeof(rasterizerDesc));
    rasterizerDesc.FillMode = D3D11_FILL_WIREFRAME;
    rasterizerDesc.CullMode = D3D11_CULL_NONE;
    rasterizerDesc.FrontCounterClockwise = false;
    rasterizerDesc.DepthClipEnable = true;
    HR(m_pd3dDevice->CreateRasterizerState(&rasterizerDesc, m_pWireMode.GetAddressOf()));
```

对于结构体D3D11_RASTERIZER_DESC和方法CreateRasterizerState的解释：

1）在创建光栅化状态前，我们需要先填充`D3D11_RASTERIZER_DESC`结构体来描述光栅化状态：

```cpp
typedef struct D3D11_RASTERIZER_DESC
{
    D3D11_FILL_MODE FillMode;          // 填充模式
    D3D11_CULL_MODE CullMode;          // 裁剪模式
    BOOL FrontCounterClockwise;        // 是否三角形顶点按逆时针排布时为正面
    INT DepthBias;                     // 深度偏移相关，目前忽略
    FLOAT DepthBiasClamp;              // 深度偏移相关，目前忽略
    FLOAT SlopeScaledDepthBias;        // 深度偏移相关，目前忽略
    BOOL DepthClipEnable;              // 是否允许深度测试将范围外的像素进行裁剪，默认TRUE
    BOOL ScissorEnable;                // 是否允许指定矩形范围的裁剪，若TRUE，则需要在RSSetScissor设置像素保留的矩形区域
    BOOL MultisampleEnable;            // 是否允许多重采样
    BOOL AntialiasedLineEnable;        // 是否允许反走样线，仅当多重采样为FALSE时才有效
}     D3D11_RASTERIZER_DESC;
```

对于枚举类型`D3D11_FILL_MODE`有如下枚举值：

| 枚举值                   | 含义         |
| ------------------------ | ------------ |
| D3D11_FILL_WIREFRAME = 2 | 线框填充方式 |
| D3D11_FILL_SOLID = 3     | 面填充方式   |

枚举类型`D3D11_CULL_MODE`有如下枚举值：

| 枚举值               | 含义                                                   |
| -------------------- | ------------------------------------------------------ |
| D3D11_CULL_NONE = 1  | 无背面裁剪，即三角形无论处在视野的正面还是背面都能看到 |
| D3D11_CULL_FRONT = 2 | 对处在视野正面的三角形进行裁剪                         |
| D3D11_CULL_BACK = 3  | 对处在视野背面的三角形进行裁剪                         |

2）光栅化创建的方法ID3D11Device::CreateRasterizerState如下：

```cpp
HRESULT ID3D11Device::CreateRasterizerState( 
    const D3D11_RASTERIZER_DESC *pRasterizerDesc,    // [In]光栅化状态描述
    ID3D11RasterizerState **ppRasterizerState) = 0;  // [Out]输出光栅化状态
```

补充一点：默认的光栅化状态

```cpp
FillMode = D3D11_FILL_SOLID;
CullMode = D3D11_CULL_BACK;
FrontCounterClockwise = FALSE;
DepthBias = 0;
SlopeScaledDepthBias = 0.0f;
DepthBiasClamp = 0.0f;
DepthClipEnable    = TRUE;
ScissorEnable = FALSE;
MultisampleEnable = FALSE;
AntialiasedLineEnable = FALSE;
```

## 3.通过RSSetState方法来改变线框模式

在GameApp::UpdateScene中，用ImGui添加一个复选框如下：

```cpp
if (ImGui::Begin("WireFrameMode"))
    {
        if (ImGui::Checkbox("WireFrame Mode", &m_IsWireframeMode))
        {
            m_pd3dImmediateContext->RSSetState(m_IsWireframeMode ? m_pWireMode.Get() : nullptr);
        }
    }
    ImGui::End();
    ImGui::Render();
```

对于RSSetState方法的解释

```cpp
void ID3D11DeviceContext::RSSetState(
  ID3D11RasterizerState *pRasterizerState);  // [In]光栅化状态，若为nullptr，则使用默认光栅化状态
```

## 4.效果展示

![](C:\Users\25768\Desktop\作业\训练营作业\小组\博客图片\线框模式.gif)