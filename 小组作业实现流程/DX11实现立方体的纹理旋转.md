这里我基于Xjun的DX11教程项目09进行修改
# 修改顶点着色器代码
为了让纹理旋转，我们需要让纹理坐标与一个旋转矩阵相乘，需要用到mul函数来实现矩阵相乘
需要将顶点着色器代码修改如下：
```cpp
VertexPosHWNormalTex VS(VertexPosNormalTex vIn)
{
    VertexPosHWNormalTex vOut;
    matrix viewProj = mul(g_View, g_Proj);
    float4 posW = mul(float4(vIn.posL, 1.0f), g_World);

    vOut.posH = mul(posW, viewProj);
    vOut.posW = posW.xyz;
    vOut.normalW = mul(vIn.normalL, (float3x3) g_WorldInvTranspose);
    vOut.tex = mul(float4(vIn.tex, 0.0f, 1.0f), g_WorldInvTranspose); //修改的部分
    return vOut;
}
```
# 将旋转矩阵赋值给矩阵g_WorldInvTranspose
这里我们修改的顶点着色器的数据，所以要通过修改顶点的常量缓冲区存入的数据，实现旋转，这里我们通过修改结构体VSConstantBuffer里的成员，矩阵g_WorldInvTranspose，来达到目的

```cpp
static float alpha = 0.0f;
alpha += 0.01f;//使纹理逆时针旋转
XMMATRIX RotateMatrix = XMMatrixTranslation(-0.5f, -0.5f, 0.0f) * XMMatrixRotationZ(alpha) * XMMatrixTranslation(0.5f, 0.5f, 0.0f);
        m_VSConstantBuffer.worldInvTranspose = XMMatrixTranspose(RotateMatrix);
```
这里矩阵先平移到原点再旋转的原因是避免旋转角度有误差，所以先将纹理中心平移到原点进行旋转，然后再平移回纹理中心原来的位置。

# 效果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/6cdca28af45a451aaf085ceb29d3d4ab.gif#pic_center)

